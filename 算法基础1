内容：
  1.算法基础与基础的数据结构
  2.排序
  3.查找
  4.图
  5.String
  6.算法设计
  
1.算法基础与基础的数据结构
1.1这里会有很多的概念，一开始不涉及算法，
  大O表示法：O(n)，n是操作数，在n前面加一个大写的O，
  时间复杂度：将算法执行运算的操作数丢掉低阶项，再去掉所有系数，
  操作数                  时间复杂度       名 称
  3                       O(1)            常数    
  104logn+2               O(logn)         对数
  2n+4                    O(n)            线性
  7n+9nlogn+39            O(nlogn)        nlogn
  3n^2+2n+5               O(n^2)          平方
  n^3+20000n^2+3n+4101    O(n^3)          多项式
  2^n                     O(2^n)          指数
  更关心无穷大的时候，时间复杂度，如上表，时间复杂度越来越大，也就是说耗时越来越多。
1.2一般法则
  法则1-for循环：假设循环体的时间复杂度为O(n)，循环次数为m，则这个循环的时间复杂度为O(nxm)。如O(nx1)，即O(n)。
  法则2-嵌套的for循环：对于多个循环，假设循环体的时间复杂度为O(n)，各个循环的循环次数分别是a,b,c,...,则这个循环的时间复杂度为O(nxaxbxcx...)。分析的时候应由里向外分析这些循环。如：O(mxnx1)，
  即O(mn)。
  法则3-顺序语句：各个语句的运行时间求和即可(或者说取较大值)。如O(n+n^2)，即O(n^2)。
  法则4-if/else语句：总的时间复杂度等于其中时间复杂度最大的路径的时间复杂度。如：O(n)，O(n^2)，即O(n^2)。
  分类：最坏时间复杂度，平均时间复杂度，最优时间复杂度。
  我们说的时间复杂度一般是最坏时间复杂度。
1.3二分法查找：一种在有序数组中查找某一特定元素的搜索算法。        特别注意：先决条件-有序数组。如：无序，不是数组类型，则不可用。
  查找思路.搜索过程从中间元素开始： 
                               1.若中间元素正好是要查找元素，则搜索过程结束；
                               2.若某一特定元素大于或小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间开始比较；
                               3.若在某一步骤数组为空，则代表找不到。
  最坏时间复杂度O(logn)，最优时间复杂度(1)，平均时间复杂度O(logn)，空间复杂度O(1)。
  算法步骤：给定一个数组A，目标值T，查找T在A中位置。
           1.令L为0，R为n-1；
           2.若L>R，则搜索失败；
           3.令m(中间值元素)为"(L+R)/2";
           4.若Am<T,则令L为m+1并回到步骤2；
           5.若Am>T,则令R为m-1并回到步骤2；
           6.若Am=T,搜索结束，回传值m。
  实现代码：
          def binary_search(arr,key):
              start=0
              end=len(arr)-1
              while start<=end:
                mid=(start+end)/2
                if arr[mid]<key:
                  start=mid+1
                elif arr[mid]>key:
                  end=mid-1
                else:
                  renturn mid
               rerurn -1
  常见问题：  1.查找第一个/最后一个与target相等的元素
             2.查找最后一个小于target/第一个大于target的元素
             3.查找最后一个小于等于target/第一个大于等于target的元素
             4.数组的旋转(4,5,6,1,2,3)
 1.4数组和链表
 数组——为解决计算机定址问题而出现的。链表——作为原始数据类型。
 时间复杂度的比较：操作             链表       数组
                 查找              O(n)        O(1)
                 在头部插入/删除    O(1)        O(n)
                 在尾部插入/删除    O(n)        O(1)
                 在中间插入/删除    O(n)        O(n)
  链表插入/删除的时间复杂度：1.当我们要插入/删除指针当前指向的节点时，时间复杂度是O(1)；
                           2.当我们要插入/删除某个给定值的节点时，我们需要遍历链表，所以是O(n)。
  注意：链表插入/删除时间复杂度O(n)是因为需要进行遍历引起的；
        数组插入/删除时间复杂度O(n)是因为数据的拷贝覆盖导致的。
        当插入/删除很少，查询非常多，又不会out of memory，采用数组。
        当插入很多，遍历和查询检索很少，就采用链表。
                     ——数组(地址连续，类型相同)  
           ——顺序表————引用数组
           |         ——动态数组
           |
   线性表—————链表——单链表
           |     ——双链表   
           |  
           |————栈
           |————队列
   数组：数组的元素位置称作索引，利用元素的索引可以计算出该元素对应的存储地址。索引是从0开始，而不是从我们生活中习惯的1。数组支持随机访问。即arr[索引]。
   引用数组：把每一个元素都找一个地方放进去，然后可以获得所放位置的地址，地址实际上就是一串数字，它的位数也是固定的，于是我们再把地址存放到数组中，这样就可以通过索引值以常量时间访问到元素的内容。
   这种方法极大的方便了我们的操作，我们的数据再也不担心数据类型不统一导致不能放在一起。
   注意：python的List就是采用的这个原理，这样解决了数据类型必须一致的问题。
   动态数组：没有长度限制的引用数组。python里的List，java里面的ArrayList,就是动态数组。
   (newsize>>3)+(newsize<9?3:6)
    新元素个数，  扩容空间
    个人觉得python的扩容更科学。
    链表：
      单向链表：它包含当前节点的值和一个指向下一节点的链接，而组后一个节点指向空值。
      双向链表：头节点不存元素
      遍历链表过程：从头节点开始，通过每个节点next的引用，可以从一个节点移动到另一个节点，当next指向空时，该节点为尾节点。
      循环链表：首尾节点连接一起，(单双都可以)。
    常见问题：    1.单链表的创建和遍历
                 2.查找单链表中的倒数第k个节点
                 3.单链表的反转
                 4.合并两个有序的单链表，合并之后的链表依然有序
                 5.判断两个单链表相交的第一个交点
                 6.查找单链表中的中间节点
                 7.从尾到头打印单链表
                 8.判断单链表是否有环
                 9.单链表中，取出环的起始点
     1.5栈和队列
       栈：  先进先出  LIFO
       队列：先进先出  FIFO
       使用：用在计算过程中，保存临时数据的，程序工作中，产生的中间数据，我就把不能立刻用的数据存起来，如果事先确定生成的数据，可以设置几个临时变量，作为临时存储，如不能，就必须采用缓存机制，如：
       栈和队列。
       栈的操作：   S.push(e)增加元素到栈中，压入栈中；
                   S.pop()移除栈顶元素，并返回，弹出栈；
                   S.top()看最上面时是谁；
                   S.is_empty()确认栈是否包含元素；
                   len(S)检查栈长度。
                   栈的操作类似于吃自助拿盘子。
       队列的操作： Q.enqueue(e)队尾插入一个元素；
                   Q.dequeue()取出队列第1个元素；
                   Q.first()看第一个是谁；
                   Q.is_empty()确认队列是否包含元素
                   len(Q)检查队列长度
                   队列的操作类似与现实中排队，先来后到。

      
      
      
      
      
      
      
      
      
      
      
              
              
              
              
              
              
              
              
              
              
              
              
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
