常见算法排序：
            冒泡排序   快速排序   希尔排序
            选择排序   堆排序     计数排序
            插入排序   归并排序   基数排序
            
  1.冒泡排序(BubbleSort)
      列表每相邻两个的数，如果前面比后面大，则交换这两个数。
      一趟排序完成后，则无序区减少一个数，有序区增加一个数。
      代码关键点：趟，无序区范围，
      时间复杂度：O(n^2)
代码实现：
#!/usr/bin/env python
# _*_coding: utf-8 _*_
# @Time : 2020/10/1 13:50
# @Author : CN-JackZhang
# @File: bubble_sort.py

import random
#冒泡排序
def bubble_sort(li):
    for i in range(len(li)-1):  # 第i趟
        exchange = False
        for j in range(len(li)-i-1):
            if li[j] > li[j+1]:
                li[j+1], li[j] = li[j], li[j+1]
                exchange=True
        if not exchange:
            return
li = [random.randint(0,10000) for i in range(1000)]  # randint生成(0,10000)随机整数，用列表生成式生成长度1000的列表
print(li)
bubble_sort(li)
print(li)
  2.选择排序(SelectSort)
    一趟排序记录最小的数，放到第一个位置。
    再一趟排序记录列表无序区最小的数，放到第二个位置
    ......
    算法关键点：有序区和无序区，无序区最小数的位置
    时间复杂度：O(n^2)
代码实现： 
#!/usr/bin/env python
# _*_coding: utf-8 _*_
# @Time : 2020/10/1 14:25
# @Author : CN-JackZhang
# @File: select_sort.py

# 选择排序
def select_sort(li):
    for i in range(len(li)-1):  # i是第几趟
        min_loc = i
        for j in range(i+1, len(li)):
            if li[j] < li[min_loc]:
                min_loc = j
        li[i], li[min_loc] = li[min_loc], li[i]
        print(li)

li = [3,4,2,1,5,6,8,7,9]
print(li)
select_sort(li)
print(li)
  3.插入排序
    初始时手里(有序区)只有一张牌。
    每次(从无序区)摸一张牌，插入到手里已有牌的正确位置。
    时间复杂度：O(n^2)
   代码实现：       
#!/usr/bin/env python
# _*_coding: utf-8 _*_
# @Time : 2020/10/1 18:56
# @Author : CN-JackZhang
# @File: insert_sort.py

# 插入算法
def insert_sort(li):
    for i in range(1, len(li)):  # 表示摸到牌的下标
        tmp = li[i]
        j = i - 1  # j指的是手里牌的下标
        while j >= 0 and li[j] > tmp:
            li[j+1] = li[j]
            j -= 1
        li[j+1] = tmp
        print(li)

li = [3,2,4,1,5,7,9,6,8]
print(li)
insert_sort(li)
print(li)    

小结：冒泡排序，选择排序，插入排序，的时间复杂度都是O(n^2)，都是原地排序。
     O(n^2)的效率怎么样？
     
   4.快速排序
   快速排序思路：
            1.取一个元素P(第一个元素)，使元素P归位，
            2.列表被P分为两部分，左边都比P小，右边都比P大，
            3.递归完成排序。
   快速排序的效率： 
            快速排序的时间复杂度：O(nlogn)
   快速排序的问题：
            最坏情况，随机化版本的快速排序，
            递归,递归会消耗很多系统资源。
   代码实现：
#!/usr/bin/env python
# _*_coding: utf-8 _*_
# @Time : 2020/10/1 19:40
# @Author : CN-JackZhang
# @File: quick_sort.py

# 快速算法

def partition(li, left, right):
    tmp = li[left]
    while left < right:
        while left < right and li[right] >= tmp:  # 从右面找比tmp小的数
            right -= 1  # 往左走一步
        li[left] = li[right]  # 把右边的值写到左边的空位上
        print(li, "right")
        while left < right and li[left] <= tmp:
            left += 1
        li[right] = li[left]    # 把左边的值写到右边空位上
        print(li, "left")
    li[left] = tmp  # 把tmp归位
    return left

def quick_sort(li, left, right):
    if left < right:    # 至少两个元素
        mid = partition(li, left, right)
        quick_sort(li, left, mid-1)
        quick_sort(li, mid+1, right)

li = [5,7,4,6,3,1,2,9,8]
print(li)
quick_sort(li, 0, len(li)-1)
print(li)

   
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       

  
